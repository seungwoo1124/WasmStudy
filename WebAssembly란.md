WebAssembly(WASM)은 2015년부터 개발된 기술로 2017년에 처음 발표되었습니다. 현재는 W3C WebAssembly Working group과 Communit Group에서 [웹 표준](https://www.w3.org/groups/wg/wasm/)으로 개발되고 있습니다. WASM은 웹 브라우저에서 실행 할 수 있는 새로운 유형의 코드입니다. wasm파일은 C, C++, Rust등의 언어를 컴파일하여 만들어지는 바이너리 형식 파일입니다. 웹에서 실행 할 수 있도록 [[컴파일 대상]]을 사용합니다.

# WebAssembly를 사용하는 이유

### 속도가 빠르다

WebAssembly를 사용하면 네이티브 컴파일 언어의 80퍼센트정도의 속도로 실행됩니다. 따라서 JavaScript만 사용 할 때 보다 큰 속도향상을 볼 수 있습니다.

#### JavaScript와 WebAssembly의 성능 차이
> JS엔진이 아래 다이어그램에서 작업 중 하나를 수행하는데 소요되는 시간은 페이지에서 사용하는 JavaScript에 따라 다릅니다. 이 다이어그램은 정확한 성능 수치를 나타내기 위한 것이 아니라 JS와 WebAssembly에서 동일한 기능에 대해 성능이 어떻게 다른지를 표현하기 위한 모델입니다.

![](https://hacks.mozilla.org/files/2017/02/05-01-diagram_now01.png)

각각의 막대는 특정 작업을 수행하는 데 소요된 시간을 보여줍니다,

+ 구문 분석 (parse) 
	+ 소스 코드를 인터프리터가 실행할 수 있는 것으로 처리하는데 걸리는 시간입니다.
+ 컴파일 + 최적화 (compile + optimize) 
	+ 기본 컴파일러 및 컴파일러 최적화에 소요되는 시간입니다. 최적화 컴파일러의 작업 중 일부는 메인 스레드에 없으므로 여기에 포함되지 않습니다.
+ 재최적화 (re-optimize) 
	+ 가정이 실패했을 때 JIT가 재조정하는데 소요되는 시간으로, 코드를 재 최적화하고 최적화된 코드를 기존 코드로 되돌립니다.
+ 실행 (execute) 
	+ 코드를 실행하는 데 걸리는 시간입니다.
+ 가비지 컬렉트 (garbage collection) 
	+ 메모리를 정리하는데 소요된 시간입니다.

한 가지 중요한 점은 이러한 작업이 개별적인 청크나 특정 순서로 발생하지 않는다는 것입니다. 대신 인터리브(interleave)됩니다. 약간의 구문 분석이 수행된 다음 실행, 컴파일, 추가 구문 분석, 실행 등이 수행됩니다.
이러한 분석이 가져오는 성능은 다음과 같은 JavaScript 초기에 비해 크게 향상되었습니다.

![](https://hacks.mozilla.org/files/2017/02/05-02-diagram_past01.png)

처음에는 JavaScript를 실행하는 인터프리터였을때는 실행이 꽤 느렸습니다. [[JIT]]가 도입되자 실행 시간이 대폭 단축되었습니다.

단점은 코드를 모니터링하고 컴파일하는 오버헤드입니다. JavaScript 개발자가 그때와 같은 방식으로 JavaScript를 게속 작성했다면 구문 분석 및 컴파일 시간이 매우 짧을 것입니다. 그러나 향상된 성능으로 인해 개발자는 더 큰 JavaScript 애플리케이션을 만들게 되었습니다.


### WebAssembly의 경우
![](https://hacks.mozilla.org/files/2017/02/05-03-diagram_future01.png)
> 이러한 모든 단계를 처리하는 방법에는 브라우저마다 약간의 차이가 있습니다. 여기서는 [[SpiderMonkey]]를 모델로 사용합니다.

- Fetching 
	- 다이어그램에는 표시되지 않지만 서버에서 파일을 가져오는 시간을 말합니다. WebAssembly는 JavaScript보다 더 컴팩트하므로 가져오는 속도가 더 빠릅니다. 압축 알고리즘이 JavaScript 번들의 크기를 크게 줄일 수 있더라도 WebAssembly의 압축된 바이너리 표현이 더 작습니다. 즉, 서버와 클라이언트 간에 전송하는 데 시간이 덜 걸립니다. 특히 느린 네트워크에서는 더욱 그렇습니다.

![](https://hacks.mozilla.org/files/2017/02/05-04-diagram_compare02.png)
- Parsing (JS) / Decode (WASM)
	- 브라우저에 도달하면 JavaScript 소스가 [[추상 구문 트리 (Abstract Syntax Tree, AST)]]로 구문 분석됩니다. 브라우저는 종종 이 작업을 게으르게 수행하여 처음에 실제로 필요한 것만 구문 분석하고 아직 호출되지 않은 함수에 대한 스텁(속이 빈 함수라고 생각)을 생성합니다. 거기에서 AST는 해당 JS엔진과 관련된 중간 표현(바이트코드)로 변환됩니다.
	- 반면 WebAssembly는 이미 중간 표현이기 때문에 이러한 변환을 거칠 필요가 없습니다. 오류가 없는지 확인하기 위해 디코딩하고 유효성을 검사하면 됩니다.

![](https://hacks.mozilla.org/files/2017/02/05-05-diagram_compare03.png)
- Compile + Optimize
	- JavaScript는 코드 실행 중에 컴파일됩니다. 런타임에 사용되는 타입에 따라 동일한 코드가 다양한 버전으로 컴파일되기도 합니다.
	- 브라우저들은 웹 어셈블리를 각자 다른 방식으로 컴파일합니다. 일부 브라우저들은 실행하기 전에 기본 컴파일 단계를 거치고, 다른 브라우저들은 JIT를 사용합니다.
	- 어떤 방식이든 웹 어셈블리가 기계 코드와 훨씬 가까운 상태에서 시작합니다. 예를 들면 프로그램의 일부로써 타입이 포함되어 있는데, 이는 다음의 몇가지 이유로 더 빠릅니다.
		1. 최적화된 코드를 컴파일하기 전에, 어떤 타입이 사용되었는지 확인하기 위해 코드를 실행해 볼 필요가 없다.
		2. 같은 코드에 대해서 여러가지 타입들이 사용되고 있을 때, 여러가지 버전으로 컴파일 할 필요가 없다.
		3. [[LLVM]]에서 이미 많은 최적화가 진행된 상태이기 때문에, 컴파일이나 최적화에 필요한 작업이 적다.

![](https://hacks.mozilla.org/files/2017/02/05-06-diagram_compare04.png)
- Re-optimizing (JS)
	- JIT는 가끔 최적화된 버전을 버리고 다시 최적화 해야합니다. 이는 JIT가 코드 실행에 기초하여 만들어낸 가정이 잘못된 것으로 판명 될 때 발생합니다. 예를 들어 순환문 내부에서 사용되는 변수에 이전 주기와는 다른 값이 할당되거나, 프로토타입 체인 내부에 다른 함수가 추가되면, [[역최적화(deoptimization)]]이 발생합니다.
	- 역최적화에는 두 가지 비용이 따릅니다. 첫째로, 최적화된 코드를 내버리고 기본 코드로 되돌릴 때 시간이 소모됩니다. 둘째로, 해당 함수가 여전히 많은 빈도로 호출되고 있다면 JIT는 해당 함수를 다시 최적화 컴파일러에게 보내기로 결정 할 수도 있는데, 여기에서 컴파일을 두 번 하는 것에 따른 비용이 발생합니다.
	- 웹 어셈블리에서는 타입과 같은 것들이 명시적이기 때문에, JIT가 런타임에 데이터를 수집해서 타입을 추론할 필요가 없습니다. 즉, Re-Optimizing단계가 필요가 없습니다.

![](https://hacks.mozilla.org/files/2017/02/05-07-diagram_compare05.png)
- Execute
	- JavaScript가 빠르게 실행될 수 있도록 작성하는 것은 가능합니다. 이를 위해서는 JIT가 어떻게 최적화 하는지에 대해 알고 있어야 합니다. 예를 들어 컴파일러가 타입을 특수화(type specialize : 타입이 항상 동일하다고 가정하고 코드를 최적화하는 과정)하도록 만드려면 어떻게 코드를 작성해야하는지를 알아야 합니다.
	- 하지만, 대부분의 개발자들은 JIT 내부에 대해서 알지 못합니다. 심지어 JIT내부에 대해서 알고 있는 개발자들도, 정확한 개선 포인트를 알기는 쉽지 않습니다. 코드를 읽기 쉽게 만들기 위해 사용되는 코딩 패턴들 (공통 작업을 추상화해서 타입에 관계없이 동작하는 함수로 만드는 작업 등)은 컴파일러가 코드를 최적화하는것을 방해합니다.
	- 게다가 JIT가 사용하는 최적화는 브라우저마다 달라서, 특정 브라우저에 맞추어 코딩을 하면 다른 브라우저에서는 성능이 느릴 수도 있습니다. 이러한 이유로, 웹 어셈블리로 작성된 코드를 실행하는것은 일반적으로 더 빠릅니다. JavaScript를 위해 JIT가 하는 많은 최적화 작업들 (타입 특수화와 같은)은 웹 어셈블리에서는 전혀 필요 없습니다.

![](https://hacks.mozilla.org/files/2017/02/05-08-diagram_compare06.png)
- Garbage Collect (JS)
	- JavaScript에서 개발자들은 더이상 필요 없는 오래된 변수들을 메모리에서 제거하는 작업을 할 필요 없이 JavaScript 엔진이 가비지 컬렉터를 이용해 이런 작업을 자동으로 해줍니다.
	- 하지만 예측가능한 성능을 원할 경우에 문제가 될 수 있습니다. 가비지 컬렉터가 언제 작동 할 지 제어할 수 없기 때문에, 안 좋은 타이밍에 실행될지도 모릅니다. 대부분의 브라우저들은 이를 잘 스케쥴링해주고 있지만, 여전히 코드 실행을 방해하는 요인이 될 수도 있습니다.
	- 현재까지, 웹 어셈블리는 가비지 컬렉션을 지원하지 않습니다. 메모리를 수동으로 (C, C++같이)관리됩니다. 이로 인해 프로그래밍 하기는 더 어려울 수 있지만, 성능에 있어서는 더 안정된 결과를 만들 수 있습니다.


### WebAssembly가 빠른 이유 결론
- WebAssebly코드가 JavaScript코드보다 컴팩트하기 때문에 Fetching에 시간이 덜 걸립니다.
- WebAssembly코드를 Decode하는 시간이 JavaScript의 Parse하는 시간보다 적게 걸립니다.
- WebAssembly코드는 JavaScript코드보다 더 머신 코드에 가깝고, 서버단에서 미리 최적화 되어있기 때문에 컴파일하고 최적화하는 시간이 적게 걸립니다.
- WebAssembly는 타입이나 다른 정보가 미리 내장되어 있기 때문에, JavaScript 엔진이 실행 시점에 분석할 필요가 없어서 Re-optimize하는 시간이 필요가 없습니다.
- WebAssembly 코드는 성능을 위해 컴파일러를 느리게 만드는 요인들에 대해 개발자들이 미리 알고 있을 필요가 없으며, 머신에 적합한 명령어 셋을 갖고 있기 때문에 실행시간도 주로 더 적게 걸립니다.
- 메모리를 직접 관리하기 때문에 Garbage collection이 필요가 없습니다.